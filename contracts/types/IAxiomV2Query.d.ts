/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

import {
  ethers,
  EventFilter,
  Signer,
  BigNumber,
  BigNumberish,
  PopulatedTransaction,
  BaseContract,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  CallOverrides,
} from "ethers";
import { BytesLike } from "@ethersproject/bytes";
import { Listener, Provider } from "@ethersproject/providers";
import { FunctionFragment, EventFragment, Result } from "@ethersproject/abi";
import type { TypedEventFilter, TypedEvent, TypedListener } from "./common";

interface IAxiomV2QueryInterface extends ethers.utils.Interface {
  functions: {
    "deposit(address)": FunctionFragment;
    "fulfillOffchainQuery((uint32,bytes32[],bytes32[]),bytes32[],bytes,(address,bytes),address,bytes32)": FunctionFragment;
    "fulfillQuery((uint32,bytes32[],bytes32[]),bytes32[],bytes,(address,bytes),(address,bytes32,bytes32,bytes32,address))": FunctionFragment;
    "increaseQueryGas(uint256,uint64,uint32)": FunctionFragment;
    "refundQuery((address,bytes32,bytes32,bytes32,address))": FunctionFragment;
    "sendQuery(uint64,bytes32,(uint8,uint16,bytes32[],bytes),(address,bytes),bytes32,uint64,uint32,address,bytes)": FunctionFragment;
    "sendQueryWithIpfsData(bytes32,bytes32,(address,bytes),bytes32,uint64,uint32,address)": FunctionFragment;
    "unescrow((address,bytes32,bytes32,bytes32,address),uint256)": FunctionFragment;
    "withdraw(uint256,address)": FunctionFragment;
  };

  encodeFunctionData(functionFragment: "deposit", values: [string]): string;
  encodeFunctionData(
    functionFragment: "fulfillOffchainQuery",
    values: [
      {
        snapshotPmmrSize: BigNumberish;
        proofMmrPeaks: BytesLike[];
        mmrComplementOrPeaks: BytesLike[];
      },
      BytesLike[],
      BytesLike,
      { target: string; extraData: BytesLike },
      string,
      BytesLike
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "fulfillQuery",
    values: [
      {
        snapshotPmmrSize: BigNumberish;
        proofMmrPeaks: BytesLike[];
        mmrComplementOrPeaks: BytesLike[];
      },
      BytesLike[],
      BytesLike,
      { target: string; extraData: BytesLike },
      {
        caller: string;
        userSalt: BytesLike;
        queryHash: BytesLike;
        callbackHash: BytesLike;
        refundee: string;
      }
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "increaseQueryGas",
    values: [BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "refundQuery",
    values: [
      {
        caller: string;
        userSalt: BytesLike;
        queryHash: BytesLike;
        callbackHash: BytesLike;
        refundee: string;
      }
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "sendQuery",
    values: [
      BigNumberish,
      BytesLike,
      {
        k: BigNumberish;
        resultLen: BigNumberish;
        vkey: BytesLike[];
        computeProof: BytesLike;
      },
      { target: string; extraData: BytesLike },
      BytesLike,
      BigNumberish,
      BigNumberish,
      string,
      BytesLike
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "sendQueryWithIpfsData",
    values: [
      BytesLike,
      BytesLike,
      { target: string; extraData: BytesLike },
      BytesLike,
      BigNumberish,
      BigNumberish,
      string
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "unescrow",
    values: [
      {
        caller: string;
        userSalt: BytesLike;
        queryHash: BytesLike;
        callbackHash: BytesLike;
        refundee: string;
      },
      BigNumberish
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "withdraw",
    values: [BigNumberish, string]
  ): string;

  decodeFunctionResult(functionFragment: "deposit", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "fulfillOffchainQuery",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "fulfillQuery",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "increaseQueryGas",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "refundQuery",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "sendQuery", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "sendQueryWithIpfsData",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "unescrow", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "withdraw", data: BytesLike): Result;

  events: {
    "AddAggregateVkeyHash(bytes32)": EventFragment;
    "Deposit(address,uint256)": EventFragment;
    "Escrow(address,uint256,uint256)": EventFragment;
    "OffchainQueryFulfilled(uint256)": EventFragment;
    "QueryFeeInfoRecorded(uint256,uint32,uint64,uint32)": EventFragment;
    "QueryFulfilled(uint256,address)": EventFragment;
    "QueryGasIncreased(uint256,uint64,uint32)": EventFragment;
    "QueryInitiatedOnchain(address,bytes32,uint256,bytes32,address,address,bytes)": EventFragment;
    "QueryInitiatedWithIpfsData(address,bytes32,uint256,bytes32,bytes32,address,address,bytes)": EventFragment;
    "QueryRefunded(uint256,address)": EventFragment;
    "RemoveAggregateVkeyHash(bytes32)": EventFragment;
    "Unescrow(address,uint256,address,address,uint256)": EventFragment;
    "UpdateAxiomHeaderVerifierAddress(address)": EventFragment;
    "UpdateAxiomProverAddress(address)": EventFragment;
    "UpdateAxiomQueryFee(uint256)": EventFragment;
    "UpdateAxiomResultStoreAddress(address)": EventFragment;
    "UpdateProofVerificationGas(uint32)": EventFragment;
    "UpdateQueryDeadlineInterval(uint32)": EventFragment;
    "UpdateVerifierAddress(address)": EventFragment;
    "Withdraw(address,uint256,address)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "AddAggregateVkeyHash"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Deposit"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Escrow"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OffchainQueryFulfilled"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "QueryFeeInfoRecorded"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "QueryFulfilled"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "QueryGasIncreased"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "QueryInitiatedOnchain"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "QueryInitiatedWithIpfsData"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "QueryRefunded"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "RemoveAggregateVkeyHash"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Unescrow"): EventFragment;
  getEvent(
    nameOrSignatureOrTopic: "UpdateAxiomHeaderVerifierAddress"
  ): EventFragment;
  getEvent(nameOrSignatureOrTopic: "UpdateAxiomProverAddress"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "UpdateAxiomQueryFee"): EventFragment;
  getEvent(
    nameOrSignatureOrTopic: "UpdateAxiomResultStoreAddress"
  ): EventFragment;
  getEvent(nameOrSignatureOrTopic: "UpdateProofVerificationGas"): EventFragment;
  getEvent(
    nameOrSignatureOrTopic: "UpdateQueryDeadlineInterval"
  ): EventFragment;
  getEvent(nameOrSignatureOrTopic: "UpdateVerifierAddress"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Withdraw"): EventFragment;
}

export type AddAggregateVkeyHashEvent = TypedEvent<
  [string] & { aggregateVkeyHash: string }
>;

export type DepositEvent = TypedEvent<
  [string, BigNumber] & { payor: string; amount: BigNumber }
>;

export type EscrowEvent = TypedEvent<
  [string, BigNumber, BigNumber] & {
    payor: string;
    queryId: BigNumber;
    amount: BigNumber;
  }
>;

export type OffchainQueryFulfilledEvent = TypedEvent<
  [BigNumber] & { queryId: BigNumber }
>;

export type QueryFeeInfoRecordedEvent = TypedEvent<
  [BigNumber, number, BigNumber, number] & {
    queryId: BigNumber;
    deadlineBlockNumber: number;
    maxFeePerGas: BigNumber;
    callbackGasLimit: number;
  }
>;

export type QueryFulfilledEvent = TypedEvent<
  [BigNumber, string] & { queryId: BigNumber; payee: string }
>;

export type QueryGasIncreasedEvent = TypedEvent<
  [BigNumber, BigNumber, number] & {
    queryId: BigNumber;
    maxFeePerGas: BigNumber;
    callbackGasLimit: number;
  }
>;

export type QueryInitiatedOnchainEvent = TypedEvent<
  [string, string, BigNumber, string, string, string, string] & {
    caller: string;
    queryHash: string;
    queryId: BigNumber;
    userSalt: string;
    refundee: string;
    target: string;
    extraData: string;
  }
>;

export type QueryInitiatedWithIpfsDataEvent = TypedEvent<
  [string, string, BigNumber, string, string, string, string, string] & {
    caller: string;
    queryHash: string;
    queryId: BigNumber;
    userSalt: string;
    ipfsHash: string;
    refundee: string;
    target: string;
    extraData: string;
  }
>;

export type QueryRefundedEvent = TypedEvent<
  [BigNumber, string] & { queryId: BigNumber; refundee: string }
>;

export type RemoveAggregateVkeyHashEvent = TypedEvent<
  [string] & { aggregateVkeyHash: string }
>;

export type UnescrowEvent = TypedEvent<
  [string, BigNumber, string, string, BigNumber] & {
    payor: string;
    queryId: BigNumber;
    payee: string;
    refundee: string;
    amountUsed: BigNumber;
  }
>;

export type UpdateAxiomHeaderVerifierAddressEvent = TypedEvent<
  [string] & { newAddress: string }
>;

export type UpdateAxiomProverAddressEvent = TypedEvent<
  [string] & { newAddress: string }
>;

export type UpdateAxiomQueryFeeEvent = TypedEvent<
  [BigNumber] & { newAxiomQueryFee: BigNumber }
>;

export type UpdateAxiomResultStoreAddressEvent = TypedEvent<
  [string] & { newAddress: string }
>;

export type UpdateProofVerificationGasEvent = TypedEvent<
  [number] & { newProofVerificationGas: number }
>;

export type UpdateQueryDeadlineIntervalEvent = TypedEvent<
  [number] & { newQueryDeadlineInterval: number }
>;

export type UpdateVerifierAddressEvent = TypedEvent<
  [string] & { newAddress: string }
>;

export type WithdrawEvent = TypedEvent<
  [string, BigNumber, string] & {
    payor: string;
    amount: BigNumber;
    payee: string;
  }
>;

export class IAxiomV2Query extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  listeners<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter?: TypedEventFilter<EventArgsArray, EventArgsObject>
  ): Array<TypedListener<EventArgsArray, EventArgsObject>>;
  off<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  on<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  once<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  removeListener<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  removeAllListeners<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>
  ): this;

  listeners(eventName?: string): Array<Listener>;
  off(eventName: string, listener: Listener): this;
  on(eventName: string, listener: Listener): this;
  once(eventName: string, listener: Listener): this;
  removeListener(eventName: string, listener: Listener): this;
  removeAllListeners(eventName?: string): this;

  queryFilter<EventArgsArray extends Array<any>, EventArgsObject>(
    event: TypedEventFilter<EventArgsArray, EventArgsObject>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEvent<EventArgsArray & EventArgsObject>>>;

  interface: IAxiomV2QueryInterface;

  functions: {
    deposit(
      payor: string,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    fulfillOffchainQuery(
      mmrWitness: {
        snapshotPmmrSize: BigNumberish;
        proofMmrPeaks: BytesLike[];
        mmrComplementOrPeaks: BytesLike[];
      },
      computeResults: BytesLike[],
      proof: BytesLike,
      callback: { target: string; extraData: BytesLike },
      caller: string,
      userSalt: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    fulfillQuery(
      mmrWitness: {
        snapshotPmmrSize: BigNumberish;
        proofMmrPeaks: BytesLike[];
        mmrComplementOrPeaks: BytesLike[];
      },
      computeResults: BytesLike[],
      proof: BytesLike,
      callback: { target: string; extraData: BytesLike },
      queryWitness: {
        caller: string;
        userSalt: BytesLike;
        queryHash: BytesLike;
        callbackHash: BytesLike;
        refundee: string;
      },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    increaseQueryGas(
      queryId: BigNumberish,
      newMaxFeePerGas: BigNumberish,
      newCallbackGasLimit: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    refundQuery(
      queryWitness: {
        caller: string;
        userSalt: BytesLike;
        queryHash: BytesLike;
        callbackHash: BytesLike;
        refundee: string;
      },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    sendQuery(
      sourceChainId: BigNumberish,
      dataQueryHash: BytesLike,
      computeQuery: {
        k: BigNumberish;
        resultLen: BigNumberish;
        vkey: BytesLike[];
        computeProof: BytesLike;
      },
      callback: { target: string; extraData: BytesLike },
      userSalt: BytesLike,
      maxFeePerGas: BigNumberish,
      callbackGasLimit: BigNumberish,
      refundee: string,
      dataQuery: BytesLike,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    sendQueryWithIpfsData(
      queryHash: BytesLike,
      ipfsHash: BytesLike,
      callback: { target: string; extraData: BytesLike },
      userSalt: BytesLike,
      maxFeePerGas: BigNumberish,
      callbackGasLimit: BigNumberish,
      refundee: string,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    unescrow(
      queryWitness: {
        caller: string;
        userSalt: BytesLike;
        queryHash: BytesLike;
        callbackHash: BytesLike;
        refundee: string;
      },
      amountUsed: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    withdraw(
      amount: BigNumberish,
      payee: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;
  };

  deposit(
    payor: string,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  fulfillOffchainQuery(
    mmrWitness: {
      snapshotPmmrSize: BigNumberish;
      proofMmrPeaks: BytesLike[];
      mmrComplementOrPeaks: BytesLike[];
    },
    computeResults: BytesLike[],
    proof: BytesLike,
    callback: { target: string; extraData: BytesLike },
    caller: string,
    userSalt: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  fulfillQuery(
    mmrWitness: {
      snapshotPmmrSize: BigNumberish;
      proofMmrPeaks: BytesLike[];
      mmrComplementOrPeaks: BytesLike[];
    },
    computeResults: BytesLike[],
    proof: BytesLike,
    callback: { target: string; extraData: BytesLike },
    queryWitness: {
      caller: string;
      userSalt: BytesLike;
      queryHash: BytesLike;
      callbackHash: BytesLike;
      refundee: string;
    },
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  increaseQueryGas(
    queryId: BigNumberish,
    newMaxFeePerGas: BigNumberish,
    newCallbackGasLimit: BigNumberish,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  refundQuery(
    queryWitness: {
      caller: string;
      userSalt: BytesLike;
      queryHash: BytesLike;
      callbackHash: BytesLike;
      refundee: string;
    },
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  sendQuery(
    sourceChainId: BigNumberish,
    dataQueryHash: BytesLike,
    computeQuery: {
      k: BigNumberish;
      resultLen: BigNumberish;
      vkey: BytesLike[];
      computeProof: BytesLike;
    },
    callback: { target: string; extraData: BytesLike },
    userSalt: BytesLike,
    maxFeePerGas: BigNumberish,
    callbackGasLimit: BigNumberish,
    refundee: string,
    dataQuery: BytesLike,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  sendQueryWithIpfsData(
    queryHash: BytesLike,
    ipfsHash: BytesLike,
    callback: { target: string; extraData: BytesLike },
    userSalt: BytesLike,
    maxFeePerGas: BigNumberish,
    callbackGasLimit: BigNumberish,
    refundee: string,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  unescrow(
    queryWitness: {
      caller: string;
      userSalt: BytesLike;
      queryHash: BytesLike;
      callbackHash: BytesLike;
      refundee: string;
    },
    amountUsed: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  withdraw(
    amount: BigNumberish,
    payee: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  callStatic: {
    deposit(payor: string, overrides?: CallOverrides): Promise<void>;

    fulfillOffchainQuery(
      mmrWitness: {
        snapshotPmmrSize: BigNumberish;
        proofMmrPeaks: BytesLike[];
        mmrComplementOrPeaks: BytesLike[];
      },
      computeResults: BytesLike[],
      proof: BytesLike,
      callback: { target: string; extraData: BytesLike },
      caller: string,
      userSalt: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    fulfillQuery(
      mmrWitness: {
        snapshotPmmrSize: BigNumberish;
        proofMmrPeaks: BytesLike[];
        mmrComplementOrPeaks: BytesLike[];
      },
      computeResults: BytesLike[],
      proof: BytesLike,
      callback: { target: string; extraData: BytesLike },
      queryWitness: {
        caller: string;
        userSalt: BytesLike;
        queryHash: BytesLike;
        callbackHash: BytesLike;
        refundee: string;
      },
      overrides?: CallOverrides
    ): Promise<void>;

    increaseQueryGas(
      queryId: BigNumberish,
      newMaxFeePerGas: BigNumberish,
      newCallbackGasLimit: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    refundQuery(
      queryWitness: {
        caller: string;
        userSalt: BytesLike;
        queryHash: BytesLike;
        callbackHash: BytesLike;
        refundee: string;
      },
      overrides?: CallOverrides
    ): Promise<void>;

    sendQuery(
      sourceChainId: BigNumberish,
      dataQueryHash: BytesLike,
      computeQuery: {
        k: BigNumberish;
        resultLen: BigNumberish;
        vkey: BytesLike[];
        computeProof: BytesLike;
      },
      callback: { target: string; extraData: BytesLike },
      userSalt: BytesLike,
      maxFeePerGas: BigNumberish,
      callbackGasLimit: BigNumberish,
      refundee: string,
      dataQuery: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    sendQueryWithIpfsData(
      queryHash: BytesLike,
      ipfsHash: BytesLike,
      callback: { target: string; extraData: BytesLike },
      userSalt: BytesLike,
      maxFeePerGas: BigNumberish,
      callbackGasLimit: BigNumberish,
      refundee: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    unescrow(
      queryWitness: {
        caller: string;
        userSalt: BytesLike;
        queryHash: BytesLike;
        callbackHash: BytesLike;
        refundee: string;
      },
      amountUsed: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    withdraw(
      amount: BigNumberish,
      payee: string,
      overrides?: CallOverrides
    ): Promise<void>;
  };

  filters: {
    "AddAggregateVkeyHash(bytes32)"(
      aggregateVkeyHash?: null
    ): TypedEventFilter<[string], { aggregateVkeyHash: string }>;

    AddAggregateVkeyHash(
      aggregateVkeyHash?: null
    ): TypedEventFilter<[string], { aggregateVkeyHash: string }>;

    "Deposit(address,uint256)"(
      payor?: string | null,
      amount?: null
    ): TypedEventFilter<
      [string, BigNumber],
      { payor: string; amount: BigNumber }
    >;

    Deposit(
      payor?: string | null,
      amount?: null
    ): TypedEventFilter<
      [string, BigNumber],
      { payor: string; amount: BigNumber }
    >;

    "Escrow(address,uint256,uint256)"(
      payor?: string | null,
      queryId?: BigNumberish | null,
      amount?: null
    ): TypedEventFilter<
      [string, BigNumber, BigNumber],
      { payor: string; queryId: BigNumber; amount: BigNumber }
    >;

    Escrow(
      payor?: string | null,
      queryId?: BigNumberish | null,
      amount?: null
    ): TypedEventFilter<
      [string, BigNumber, BigNumber],
      { payor: string; queryId: BigNumber; amount: BigNumber }
    >;

    "OffchainQueryFulfilled(uint256)"(
      queryId?: BigNumberish | null
    ): TypedEventFilter<[BigNumber], { queryId: BigNumber }>;

    OffchainQueryFulfilled(
      queryId?: BigNumberish | null
    ): TypedEventFilter<[BigNumber], { queryId: BigNumber }>;

    "QueryFeeInfoRecorded(uint256,uint32,uint64,uint32)"(
      queryId?: BigNumberish | null,
      deadlineBlockNumber?: null,
      maxFeePerGas?: null,
      callbackGasLimit?: null
    ): TypedEventFilter<
      [BigNumber, number, BigNumber, number],
      {
        queryId: BigNumber;
        deadlineBlockNumber: number;
        maxFeePerGas: BigNumber;
        callbackGasLimit: number;
      }
    >;

    QueryFeeInfoRecorded(
      queryId?: BigNumberish | null,
      deadlineBlockNumber?: null,
      maxFeePerGas?: null,
      callbackGasLimit?: null
    ): TypedEventFilter<
      [BigNumber, number, BigNumber, number],
      {
        queryId: BigNumber;
        deadlineBlockNumber: number;
        maxFeePerGas: BigNumber;
        callbackGasLimit: number;
      }
    >;

    "QueryFulfilled(uint256,address)"(
      queryId?: BigNumberish | null,
      payee?: null
    ): TypedEventFilter<
      [BigNumber, string],
      { queryId: BigNumber; payee: string }
    >;

    QueryFulfilled(
      queryId?: BigNumberish | null,
      payee?: null
    ): TypedEventFilter<
      [BigNumber, string],
      { queryId: BigNumber; payee: string }
    >;

    "QueryGasIncreased(uint256,uint64,uint32)"(
      queryId?: BigNumberish | null,
      maxFeePerGas?: null,
      callbackGasLimit?: null
    ): TypedEventFilter<
      [BigNumber, BigNumber, number],
      { queryId: BigNumber; maxFeePerGas: BigNumber; callbackGasLimit: number }
    >;

    QueryGasIncreased(
      queryId?: BigNumberish | null,
      maxFeePerGas?: null,
      callbackGasLimit?: null
    ): TypedEventFilter<
      [BigNumber, BigNumber, number],
      { queryId: BigNumber; maxFeePerGas: BigNumber; callbackGasLimit: number }
    >;

    "QueryInitiatedOnchain(address,bytes32,uint256,bytes32,address,address,bytes)"(
      caller?: string | null,
      queryHash?: BytesLike | null,
      queryId?: BigNumberish | null,
      userSalt?: null,
      refundee?: null,
      target?: null,
      extraData?: null
    ): TypedEventFilter<
      [string, string, BigNumber, string, string, string, string],
      {
        caller: string;
        queryHash: string;
        queryId: BigNumber;
        userSalt: string;
        refundee: string;
        target: string;
        extraData: string;
      }
    >;

    QueryInitiatedOnchain(
      caller?: string | null,
      queryHash?: BytesLike | null,
      queryId?: BigNumberish | null,
      userSalt?: null,
      refundee?: null,
      target?: null,
      extraData?: null
    ): TypedEventFilter<
      [string, string, BigNumber, string, string, string, string],
      {
        caller: string;
        queryHash: string;
        queryId: BigNumber;
        userSalt: string;
        refundee: string;
        target: string;
        extraData: string;
      }
    >;

    "QueryInitiatedWithIpfsData(address,bytes32,uint256,bytes32,bytes32,address,address,bytes)"(
      caller?: string | null,
      queryHash?: BytesLike | null,
      queryId?: BigNumberish | null,
      userSalt?: null,
      ipfsHash?: null,
      refundee?: null,
      target?: null,
      extraData?: null
    ): TypedEventFilter<
      [string, string, BigNumber, string, string, string, string, string],
      {
        caller: string;
        queryHash: string;
        queryId: BigNumber;
        userSalt: string;
        ipfsHash: string;
        refundee: string;
        target: string;
        extraData: string;
      }
    >;

    QueryInitiatedWithIpfsData(
      caller?: string | null,
      queryHash?: BytesLike | null,
      queryId?: BigNumberish | null,
      userSalt?: null,
      ipfsHash?: null,
      refundee?: null,
      target?: null,
      extraData?: null
    ): TypedEventFilter<
      [string, string, BigNumber, string, string, string, string, string],
      {
        caller: string;
        queryHash: string;
        queryId: BigNumber;
        userSalt: string;
        ipfsHash: string;
        refundee: string;
        target: string;
        extraData: string;
      }
    >;

    "QueryRefunded(uint256,address)"(
      queryId?: BigNumberish | null,
      refundee?: string | null
    ): TypedEventFilter<
      [BigNumber, string],
      { queryId: BigNumber; refundee: string }
    >;

    QueryRefunded(
      queryId?: BigNumberish | null,
      refundee?: string | null
    ): TypedEventFilter<
      [BigNumber, string],
      { queryId: BigNumber; refundee: string }
    >;

    "RemoveAggregateVkeyHash(bytes32)"(
      aggregateVkeyHash?: null
    ): TypedEventFilter<[string], { aggregateVkeyHash: string }>;

    RemoveAggregateVkeyHash(
      aggregateVkeyHash?: null
    ): TypedEventFilter<[string], { aggregateVkeyHash: string }>;

    "Unescrow(address,uint256,address,address,uint256)"(
      payor?: string | null,
      queryId?: BigNumberish | null,
      payee?: string | null,
      refundee?: null,
      amountUsed?: null
    ): TypedEventFilter<
      [string, BigNumber, string, string, BigNumber],
      {
        payor: string;
        queryId: BigNumber;
        payee: string;
        refundee: string;
        amountUsed: BigNumber;
      }
    >;

    Unescrow(
      payor?: string | null,
      queryId?: BigNumberish | null,
      payee?: string | null,
      refundee?: null,
      amountUsed?: null
    ): TypedEventFilter<
      [string, BigNumber, string, string, BigNumber],
      {
        payor: string;
        queryId: BigNumber;
        payee: string;
        refundee: string;
        amountUsed: BigNumber;
      }
    >;

    "UpdateAxiomHeaderVerifierAddress(address)"(
      newAddress?: null
    ): TypedEventFilter<[string], { newAddress: string }>;

    UpdateAxiomHeaderVerifierAddress(
      newAddress?: null
    ): TypedEventFilter<[string], { newAddress: string }>;

    "UpdateAxiomProverAddress(address)"(
      newAddress?: null
    ): TypedEventFilter<[string], { newAddress: string }>;

    UpdateAxiomProverAddress(
      newAddress?: null
    ): TypedEventFilter<[string], { newAddress: string }>;

    "UpdateAxiomQueryFee(uint256)"(
      newAxiomQueryFee?: null
    ): TypedEventFilter<[BigNumber], { newAxiomQueryFee: BigNumber }>;

    UpdateAxiomQueryFee(
      newAxiomQueryFee?: null
    ): TypedEventFilter<[BigNumber], { newAxiomQueryFee: BigNumber }>;

    "UpdateAxiomResultStoreAddress(address)"(
      newAddress?: null
    ): TypedEventFilter<[string], { newAddress: string }>;

    UpdateAxiomResultStoreAddress(
      newAddress?: null
    ): TypedEventFilter<[string], { newAddress: string }>;

    "UpdateProofVerificationGas(uint32)"(
      newProofVerificationGas?: null
    ): TypedEventFilter<[number], { newProofVerificationGas: number }>;

    UpdateProofVerificationGas(
      newProofVerificationGas?: null
    ): TypedEventFilter<[number], { newProofVerificationGas: number }>;

    "UpdateQueryDeadlineInterval(uint32)"(
      newQueryDeadlineInterval?: null
    ): TypedEventFilter<[number], { newQueryDeadlineInterval: number }>;

    UpdateQueryDeadlineInterval(
      newQueryDeadlineInterval?: null
    ): TypedEventFilter<[number], { newQueryDeadlineInterval: number }>;

    "UpdateVerifierAddress(address)"(
      newAddress?: null
    ): TypedEventFilter<[string], { newAddress: string }>;

    UpdateVerifierAddress(
      newAddress?: null
    ): TypedEventFilter<[string], { newAddress: string }>;

    "Withdraw(address,uint256,address)"(
      payor?: string | null,
      amount?: null,
      payee?: null
    ): TypedEventFilter<
      [string, BigNumber, string],
      { payor: string; amount: BigNumber; payee: string }
    >;

    Withdraw(
      payor?: string | null,
      amount?: null,
      payee?: null
    ): TypedEventFilter<
      [string, BigNumber, string],
      { payor: string; amount: BigNumber; payee: string }
    >;
  };

  estimateGas: {
    deposit(
      payor: string,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    fulfillOffchainQuery(
      mmrWitness: {
        snapshotPmmrSize: BigNumberish;
        proofMmrPeaks: BytesLike[];
        mmrComplementOrPeaks: BytesLike[];
      },
      computeResults: BytesLike[],
      proof: BytesLike,
      callback: { target: string; extraData: BytesLike },
      caller: string,
      userSalt: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    fulfillQuery(
      mmrWitness: {
        snapshotPmmrSize: BigNumberish;
        proofMmrPeaks: BytesLike[];
        mmrComplementOrPeaks: BytesLike[];
      },
      computeResults: BytesLike[],
      proof: BytesLike,
      callback: { target: string; extraData: BytesLike },
      queryWitness: {
        caller: string;
        userSalt: BytesLike;
        queryHash: BytesLike;
        callbackHash: BytesLike;
        refundee: string;
      },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    increaseQueryGas(
      queryId: BigNumberish,
      newMaxFeePerGas: BigNumberish,
      newCallbackGasLimit: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    refundQuery(
      queryWitness: {
        caller: string;
        userSalt: BytesLike;
        queryHash: BytesLike;
        callbackHash: BytesLike;
        refundee: string;
      },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    sendQuery(
      sourceChainId: BigNumberish,
      dataQueryHash: BytesLike,
      computeQuery: {
        k: BigNumberish;
        resultLen: BigNumberish;
        vkey: BytesLike[];
        computeProof: BytesLike;
      },
      callback: { target: string; extraData: BytesLike },
      userSalt: BytesLike,
      maxFeePerGas: BigNumberish,
      callbackGasLimit: BigNumberish,
      refundee: string,
      dataQuery: BytesLike,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    sendQueryWithIpfsData(
      queryHash: BytesLike,
      ipfsHash: BytesLike,
      callback: { target: string; extraData: BytesLike },
      userSalt: BytesLike,
      maxFeePerGas: BigNumberish,
      callbackGasLimit: BigNumberish,
      refundee: string,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    unescrow(
      queryWitness: {
        caller: string;
        userSalt: BytesLike;
        queryHash: BytesLike;
        callbackHash: BytesLike;
        refundee: string;
      },
      amountUsed: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    withdraw(
      amount: BigNumberish,
      payee: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    deposit(
      payor: string,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    fulfillOffchainQuery(
      mmrWitness: {
        snapshotPmmrSize: BigNumberish;
        proofMmrPeaks: BytesLike[];
        mmrComplementOrPeaks: BytesLike[];
      },
      computeResults: BytesLike[],
      proof: BytesLike,
      callback: { target: string; extraData: BytesLike },
      caller: string,
      userSalt: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    fulfillQuery(
      mmrWitness: {
        snapshotPmmrSize: BigNumberish;
        proofMmrPeaks: BytesLike[];
        mmrComplementOrPeaks: BytesLike[];
      },
      computeResults: BytesLike[],
      proof: BytesLike,
      callback: { target: string; extraData: BytesLike },
      queryWitness: {
        caller: string;
        userSalt: BytesLike;
        queryHash: BytesLike;
        callbackHash: BytesLike;
        refundee: string;
      },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    increaseQueryGas(
      queryId: BigNumberish,
      newMaxFeePerGas: BigNumberish,
      newCallbackGasLimit: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    refundQuery(
      queryWitness: {
        caller: string;
        userSalt: BytesLike;
        queryHash: BytesLike;
        callbackHash: BytesLike;
        refundee: string;
      },
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    sendQuery(
      sourceChainId: BigNumberish,
      dataQueryHash: BytesLike,
      computeQuery: {
        k: BigNumberish;
        resultLen: BigNumberish;
        vkey: BytesLike[];
        computeProof: BytesLike;
      },
      callback: { target: string; extraData: BytesLike },
      userSalt: BytesLike,
      maxFeePerGas: BigNumberish,
      callbackGasLimit: BigNumberish,
      refundee: string,
      dataQuery: BytesLike,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    sendQueryWithIpfsData(
      queryHash: BytesLike,
      ipfsHash: BytesLike,
      callback: { target: string; extraData: BytesLike },
      userSalt: BytesLike,
      maxFeePerGas: BigNumberish,
      callbackGasLimit: BigNumberish,
      refundee: string,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    unescrow(
      queryWitness: {
        caller: string;
        userSalt: BytesLike;
        queryHash: BytesLike;
        callbackHash: BytesLike;
        refundee: string;
      },
      amountUsed: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    withdraw(
      amount: BigNumberish,
      payee: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;
  };
}
